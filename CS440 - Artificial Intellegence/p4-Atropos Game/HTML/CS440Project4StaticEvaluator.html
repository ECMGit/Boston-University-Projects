<html><head><title>CS440 Project 4: Static Evaluator</title><style type="text/css">ol{margin:0;padding:0}.c6{max-width:468pt;background-color:#ffffff;padding:72pt 72pt 72pt 72pt}.c2{height:11pt;margin-left:36pt}.c3{text-align:center}.c5{margin-left:36pt}.c4{height:11pt}.c0{direction:ltr}.c1{font-weight:bold}.title{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:36pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}.subtitle{padding-top:18pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:24pt;font-family:"Georgia";padding-bottom:4pt}p{color:#000000;font-size:11pt;margin:0;font-family:"Arial"}h1{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:18pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}h2{padding-top:18pt;line-height:1.15;text-align:left;color:#000000;font-size:14pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h3{padding-top:14pt;line-height:1.15;text-align:left;color:#666666;font-size:12pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h4{padding-top:12pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:11pt;font-family:"Arial";padding-bottom:2pt}h5{padding-top:11pt;line-height:1.15;text-align:left;color:#666666;font-size:10pt;font-family:"Arial";font-weight:bold;padding-bottom:2pt}h6{padding-top:10pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:10pt;font-family:"Arial";padding-bottom:2pt}</style></head><body class="c6"><p class="c0 c3"><span class="c1">Project 4: Static Evaluator</span></p><p class="c3 c4 c0"><span class="c1"></span></p><p class="c0"><span class="c1">Group members:</span></p><p class="c0"><span>Chris &ldquo;See-No-Evil&rdquo; Hall</span></p><p class="c0"><span>Adam Even &ldquo;Hear-No-Evil&rdquo; Engel</span></p><p class="c0"><span>Tim &ldquo;Speak-No-Evil&rdquo; Duffy</span></p><p class="c4 c0"><span></span></p><p class="c3 c0"><img height="227" src="images/image00.jpg" width="334"></p><hr><p class="c4 c0"><span></span></p><p class="c0"><span class="c1">Purpose:</span></p><p class="c0"><span>Develop a static evaluator to determine the best next move for a player in a game of Atropos.</span></p><hr><p class="c4 c0"><span></span></p><p class="c0"><span class="c1">Implementation:</span></p><p class="c0"><span>We utilized the Java programming language for this project using the Eclipse IDE. The program implements our own algorithms to score each potential move, which is based on the number of safe moves we will have on our next turn. We assume that our opponent moves into the position that will minimize the score for our next turn.</span></p><hr><p class="c4 c0"><span></span></p><p class="c0"><span class="c1">Development:</span></p><p class="c0"><span>Our program determines the best possible move in 5 stages:</span></p><p class="c4 c0"><span class="c1"></span></p><p class="c0"><span class="c1">1) Parsing the game board:</span></p><p class="c5 c0"><span>In order to run our program, the Atropos game board and information about the last move made must be passed in as a command line argument. The first step we take is to translate the given string into an array. This array is what we base all of our evaluation upon. We also keep track of the position of the last move made.</span></p><p class="c4 c0"><span></span></p><p class="c0"><span class="c1">2) Determining all possible safe moves</span></p><p class="c5 c0"><span>Once we have put the game board into an easy to search structure, we use the information given to us about the last move to begin our search. For each open neighbor, we determine a score, based on the move we assume our opponent will make next (see next section). Once the scores for all colors in all open neighbors has been determined, we choose the move with the highest score.</span></p><p class="c0 c2"><span></span></p><p class="c0"><span class="c1">3) Determining the opponent&#39;s best possible move from our own possible moves.</span></p><p class="c5 c0"><span>We use the same logic for determining our possible safe moves to determine those of the opponent. Essentially, our program assumes the opponent thinks the same way it does and calculates their ideal move correspondingly.</span></p><p class="c2 c0"><span></span></p><p class="c0"><span class="c1">4) Maximizing the number of options for our next turn.</span></p><p class="c5 c0"><span>Yup, you guessed it. We use the same algorithm again to determine our best next move based on the opponent&rsquo;s &ldquo;best move&rdquo;. This is the crux of the prediction and how we determine where to move. We prune the moves that don&rsquo;t allow us a winning move, narrowing down our choices considerably.</span></p><p class="c2 c0"><span></span></p><p class="c0"><span class="c1">5) Handling special cases</span></p><p class="c0 c5"><span>Our program has the capability of handling certain special cases that may arise during the course of the game. If our program is given the first turn, we always begin in the same position - the center of the first (widest) row. In a situation where the opponent&rsquo;s last move has left no open neighbors, our program scans the board for the first available safe move. If there are no safe legal moves available, we gracefully choose a spot at random, and accept defeat.</span></p><p class="c2 c0"><span></span></p><p class="c0"><span>In the course of our calculations, we make a couple assumptions. First and foremost, we assume that the opponent will make the best possible move for itself using logic similar to ours. Second, we assume that a decision tree of height 3 is enough to provide a satisfactory prediction. This allows our program to make its move based on the possible moves it can make the following turn. </span></p><p class="c4 c0"><span></span></p><hr><p class="c4 c0"><span></span></p><p class="c0"><span class="c1">Results:</span></p><p class="c4 c0"><span class="c1"></span></p><p class="c0"><span>To test the effectiveness of our program, we ran several matches against a Default Atropos Player. In the 10 matches we ran, our program won 80% of the matches. This is a small sample size, but we like to think that it reflects reality. We also ran the program through ten matches against itself. </span><span>As expected, it won roughly 50% of the time. </span><span>Interestingly,</span><span>&nbsp;the player who goes second wins in 27 moves, 100% of the time, when our program runs against itself.</span></p><p class="c4 c0"><span></span></p><hr><p class="c0 c4"><span></span></p><p class="c0"><span class="c1">Instructions for Execution:</span></p><p class="c0"><span>To use our program with the Atropos Game interface, use the AtroposGame class.</span></p><p class="c4 c0"><span></span></p><p class="c0"><span>To compile: &quot;javac ThreeMonkeeyz.java &quot; or simply &ldquo;javac *.java&rdquo;</span></p><p class="c0"><span>To run: &ldquo;java AtroposGame &lt;size&gt; &ldquo;java ThreeMonkeeyz&rdquo; &lt;second script optional&gt;&rdquo;</span></p><p class="c4 c0"><span></span></p><p class="c0"><span>You can also run the multi-game bash scripts, where:</span></p><p class="c0"><span>./repeater.sh runs our program against itself 10 times with height=7</span></p><p class="c0"><span>./repeaterAgainstDefault.sh runs our program against the default player 10 times with height=7</span></p><p class="c0"><span>./repeaterAgainstDefaultRandomHeight.sh runs our program 10 times against the default with random heights of [5,10].</span></p></body></html>